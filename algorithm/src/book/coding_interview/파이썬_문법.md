# 파이썬 문법

### 네이밍 컨벤션

* 스네이크 케이스(snake_case)를 따른다.
* 타입을 명시하도록 한다.
```python
a : str = "123"
b: int = 123

def solution(a: int) -> bool:
    ...
```
* mypy를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인 할 수 있다. (제출하기 전에 꼭 해보기)
```
$mypy solution.py
``` 

### 리스트 컴프리헨션

* map, filter와 같은 함수형 기능도 지원하고, 람다 표현식도 지원한다.
```python
list(map(lambda x: x + 10, [1, 2, 3]))
#[11, 12, 13]
```

* 컴프리헨션은 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문이다.
```python
# 컴프리헨션 활용 x
#[2, 6, 10, 14, 18]
a = []
for n in range(1, 10 + 1):
    if n % 2 == 1:
        a.append(n * 2)

# 컴프리헨션 활용
#[2, 6, 10, 14, 18]
[n * 2 for n in range(1, 10 + 1) if n % 2 == 1]
```

```python
# 컴프리헨션 활용 x
a = {}
for key, value in original.items():
    a[key] = value

# 컴프리헨션 활용
a = {key: value for key, value in original.items()}
```

### 제너레이터

* 루프의 반복 동작을 제어할 수 있는 루틴 형태
* yield 구문을 사용하면 제너레이터를 리턴할 수 있다.
```python
def test():
    yield 1
    yield '2'
    print("3")
    yield '4'

a = test()
print(next(a))
print(next(a))
print(next(a))
#1 2 3 4
```

### range

* 제너레이터의 방식을 활용하는 대표적인 함수이다.
* 생성 조건만 정해두고 필요할 때 생성해서 꺼내 쓸 수 있다.
```python
list(range(5)) #[0, 1, 2, 3, 4]
range(5) #range(0, 5)
type(range(5)) #<class 'range'>
for i in range(5):
    print(i, end=' ')
#0 1 2 3 4
```

### enumerate

* '열거하다'는 뜻으로, 순서가 있는 자료형을 인덱스를 포함한 enumerate 객체로 리턴한다.
```python
a = [5, 4, 2, 6, 7]
print(enumerate(a)) #[(0, 5), (1, 4), (2, 2), (3, 6), (4, 7)]
```
* 리스트의 인덱스와 값을 모두 출력하려면 아래와 같이 enumerate를 활용하면 된다.
```python
a = [5, 4, 2, 6, 7]
for index, value in enumerate(a):
    print(index, value)
```

### // 나눗셈 연산자

* 파이썬 버전에 따라 나눗셈의 결과는 다르게 나타난다.
```python
# 파이썬 3+
print(5 / 3) #1.6666666666666667

# 파이썬 2 이하
print(5 / 3) #1
```
* //연산자는 몫을 구하는 연산자다. int(5 / 3)과 동일하게 동작한다.
```python
print(5 / 3) #1.6666666666666667
print(5 // 3) #1
print(int(5 / 3)) #1
```
* 나머지는 5 % 3으로 구하는데 몫과 나머지를 동시에 구하려면 divmod() 함수를 사용한다.
```python
print(divmod(5, 3)) #(1, 2)
```

### print

1. 콤마로 값을 구분하는데 한 칸 공백이 디폴트이다.
2. sep 파라미터로 구분자를 지정해 줄 수 있다.
3. print() 함수는 줄바꿈을 기본으로 설정되어 있는데 이를 방지하려면 end 파라미터를 설정해준다.
4. 리스트는 join()으로 묶어서 처리한다.
5. 문자열을 format하는 경우
    * format() 함수 활용
    * 인덱스 생략
    * 가장 선호하는 방법 (f-string): 파이썬 3.6+에서만 지원한다.
```python
#1. A1 B2
print('A1', 'B2')

#2. A1,B2
print('A1', 'B2', sep=',')

#3. aa bb
print('aa', end=' ')
print('bb')

#4. A B
a = ['A', 'B']
print(' '.join(a))

#5-1. 2: Apple
index = 1
fruit = "Apple"
print('{0}: {1}'.format(index + 1, fruit))

#5-2 2: Apple
print('{}: {}'.format(index + 1, fruit))

#5-3 2: Apple
print(f'{index + 1}: {fruit}')
```

### pass

* 메서드에 아무런 처리를 하지 않으면 오류가 발생한다.
* pass는 이러한 오류를 막는 역할을 한다. 즉, 아무것도 하지 않는 기능이다.
```python
class Test(object):
    def method_a(self):
        pass

    def method_b(self):
        print("hello world!")
```

# 코딩 스타일

### 변수명 주석

* 책에서는 주석을 다는 방식을 선호하며, 주석 여부를 확인하고 인터뷰 시에 이에 대해 논의 한다고 명시되어 있다.
* 변수명은 의미 없는 이름보다 의미를 부여하며, 스네이크 케이스로 작성한다.
* 주석은 한글로 달아도 무방하지만, 영어로 작성하는 것에도 부담이 없어야 한다. (읽고 쓰는 데 부담이 없어야 한다)

### 리스트 컴프리헨션

* 한 줄로 적게 되는 경우가 많은데 줄 구분을 해주거나, 경우에 따라 가독성을 위해 모두 풀어쓰는 것도 고려해보는 것이 좋다.

### 구글 파이썬 스타일 가이드

* 아래 코드처럼 함수의 기본 값으로 가변 객체를 사용하지 않아야 한다. 즉, []나 {}를 사용하는 것은 지양하자.
```python
def foo(a, b=[]):
    ...

def foo(a, b: Mapping = {}):
    ...
```
* 아래 코드처럼 불변 객체를 사용하자. None을 명시적으로 할당하는 것도 좋다.
```python
def foo(a, b=None):
    if b is None:
        b = []

def foo(a, b: Optional[Sequence] = None):
    if b is None:
        b = []
```
* True, Flase를 판별할 때 암시적인 방법을 사용하자.
```python
#1. Yes
if not users:
    ...

#1. No
if len(users) == 0:
    ...

#2. Yes
if foo == 0:
    ...

#2. No
if foo is not None and not foo:
    ...

#3. Yes
if i % 10 == 0:
    ...

#3. No
if not i % 10:
    ...


```